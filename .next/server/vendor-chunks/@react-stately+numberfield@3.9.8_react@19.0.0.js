"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately+numberfield@3.9.8_react@19.0.0";
exports.ids = ["vendor-chunks/@react-stately+numberfield@3.9.8_react@19.0.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-stately+numberfield@3.9.8_react@19.0.0/node_modules/@react-stately/numberfield/dist/useNumberFieldState.mjs":
/*!***********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-stately+numberfield@3.9.8_react@19.0.0/node_modules/@react-stately/numberfield/dist/useNumberFieldState.mjs ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useNumberFieldState: () => (/* binding */ $de67e98908f0c6ee$export$7f629e9dc1ecf37c)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/.pnpm/@react-stately+utils@3.10.5_react@19.0.0/node_modules/@react-stately/utils/dist/number.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/.pnpm/@react-stately+utils@3.10.5_react@19.0.0/node_modules/@react-stately/utils/dist/useControlledState.mjs\");\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/.pnpm/@react-stately+form@3.1.0_react@19.0.0/node_modules/@react-stately/form/dist/useFormValidationState.mjs\");\n/* harmony import */ var _internationalized_number__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @internationalized/number */ \"(ssr)/./node_modules/.pnpm/@internationalized+number@3.6.0/node_modules/@internationalized/number/dist/NumberFormatter.mjs\");\n/* harmony import */ var _internationalized_number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @internationalized/number */ \"(ssr)/./node_modules/.pnpm/@internationalized+number@3.6.0/node_modules/@internationalized/number/dist/NumberParser.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.4.6_@babel+core@7.2_b27454ec5e6826b230418c92f7d5a457/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\nfunction $de67e98908f0c6ee$export$7f629e9dc1ecf37c(props) {\n    let { minValue: minValue, maxValue: maxValue, step: step, formatOptions: formatOptions, value: value, defaultValue: defaultValue = NaN, onChange: onChange, locale: locale, isDisabled: isDisabled, isReadOnly: isReadOnly } = props;\n    if (value === null) value = NaN;\n    if (value !== undefined && !isNaN(value)) {\n        if (step !== undefined && !isNaN(step)) value = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(value, minValue, maxValue, step);\n        else value = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.clamp)(value, minValue, maxValue);\n    }\n    if (!isNaN(defaultValue)) {\n        if (step !== undefined && !isNaN(step)) defaultValue = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(defaultValue, minValue, maxValue, step);\n        else defaultValue = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.clamp)(defaultValue, minValue, maxValue);\n    }\n    let [numberValue, setNumberValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__.useControlledState)(value, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n    let [inputValue, setInputValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>isNaN(numberValue) ? '' : new (0, _internationalized_number__WEBPACK_IMPORTED_MODULE_3__.NumberFormatter)(locale, formatOptions).format(numberValue));\n    let numberParser = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _internationalized_number__WEBPACK_IMPORTED_MODULE_4__.NumberParser)(locale, formatOptions), [\n        locale,\n        formatOptions\n    ]);\n    let numberingSystem = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>numberParser.getNumberingSystem(inputValue), [\n        numberParser,\n        inputValue\n    ]);\n    let formatter = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _internationalized_number__WEBPACK_IMPORTED_MODULE_3__.NumberFormatter)(locale, {\n            ...formatOptions,\n            numberingSystem: numberingSystem\n        }), [\n        locale,\n        formatOptions,\n        numberingSystem\n    ]);\n    let intlOptions = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>formatter.resolvedOptions(), [\n        formatter\n    ]);\n    let format = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>isNaN(value) || value === null ? '' : formatter.format(value), [\n        formatter\n    ]);\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_5__.useFormValidationState)({\n        ...props,\n        value: numberValue\n    });\n    let clampStep = step !== undefined && !isNaN(step) ? step : 1;\n    if (intlOptions.style === 'percent' && (step === undefined || isNaN(step))) clampStep = 0.01;\n    // Update the input value when the number value or format options change. This is done\n    // in a useEffect so that the controlled behavior is correct and we only update the\n    // textfield after prop changes.\n    let [prevValue, setPrevValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(numberValue);\n    let [prevLocale, setPrevLocale] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(locale);\n    let [prevFormatOptions, setPrevFormatOptions] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(formatOptions);\n    if (!Object.is(numberValue, prevValue) || locale !== prevLocale || formatOptions !== prevFormatOptions) {\n        setInputValue(format(numberValue));\n        setPrevValue(numberValue);\n        setPrevLocale(locale);\n        setPrevFormatOptions(formatOptions);\n    }\n    let parsedValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>numberParser.parse(inputValue), [\n        numberParser,\n        inputValue\n    ]);\n    let commit = ()=>{\n        // Set to empty state if input value is empty\n        if (!inputValue.length) {\n            setNumberValue(NaN);\n            setInputValue(value === undefined ? '' : format(numberValue));\n            return;\n        }\n        // if it failed to parse, then reset input to formatted version of current number\n        if (isNaN(parsedValue)) {\n            setInputValue(format(numberValue));\n            return;\n        }\n        // Clamp to min and max, round to the nearest step, and round to specified number of digits\n        let clampedValue;\n        if (step === undefined || isNaN(step)) clampedValue = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.clamp)(parsedValue, minValue, maxValue);\n        else clampedValue = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(parsedValue, minValue, maxValue, step);\n        clampedValue = numberParser.parse(format(clampedValue));\n        setNumberValue(clampedValue);\n        // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n        setInputValue(format(value === undefined ? clampedValue : numberValue));\n    };\n    let safeNextStep = (operation, minMax = 0)=>{\n        let prev = parsedValue;\n        if (isNaN(prev)) {\n            // if the input is empty, start from the min/max value when incrementing/decrementing,\n            // or zero if there is no min/max value defined.\n            let newValue = isNaN(minMax) ? 0 : minMax;\n            return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(newValue, minValue, maxValue, clampStep);\n        } else {\n            // otherwise, first snap the current value to the nearest step. if it moves in the direction\n            // we're going, use that value, otherwise add the step and snap that value.\n            let newValue = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(prev, minValue, maxValue, clampStep);\n            if (operation === '+' && newValue > prev || operation === '-' && newValue < prev) return newValue;\n            return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)($de67e98908f0c6ee$var$handleDecimalOperation(operation, prev, clampStep), minValue, maxValue, clampStep);\n        }\n    };\n    let increment = ()=>{\n        let newValue = safeNextStep('+', minValue);\n        // if we've arrived at the same value that was previously in the state, the\n        // input value should be updated to match\n        // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n        // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n        if (newValue === numberValue) setInputValue(format(newValue));\n        setNumberValue(newValue);\n        validation.commitValidation();\n    };\n    let decrement = ()=>{\n        let newValue = safeNextStep('-', maxValue);\n        if (newValue === numberValue) setInputValue(format(newValue));\n        setNumberValue(newValue);\n        validation.commitValidation();\n    };\n    let incrementToMax = ()=>{\n        if (maxValue != null) {\n            setNumberValue((0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(maxValue, minValue, maxValue, clampStep));\n            validation.commitValidation();\n        }\n    };\n    let decrementToMin = ()=>{\n        if (minValue != null) {\n            setNumberValue(minValue);\n            validation.commitValidation();\n        }\n    };\n    let canIncrement = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>!isDisabled && !isReadOnly && (isNaN(parsedValue) || maxValue === undefined || isNaN(maxValue) || (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(parsedValue, minValue, maxValue, clampStep) > parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation('+', parsedValue, clampStep) <= maxValue), [\n        isDisabled,\n        isReadOnly,\n        minValue,\n        maxValue,\n        clampStep,\n        parsedValue\n    ]);\n    let canDecrement = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>!isDisabled && !isReadOnly && (isNaN(parsedValue) || minValue === undefined || isNaN(minValue) || (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(parsedValue, minValue, maxValue, clampStep) < parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation('-', parsedValue, clampStep) >= minValue), [\n        isDisabled,\n        isReadOnly,\n        minValue,\n        maxValue,\n        clampStep,\n        parsedValue\n    ]);\n    let validate = (value)=>numberParser.isValidPartialNumber(value, minValue, maxValue);\n    return {\n        ...validation,\n        validate: validate,\n        increment: increment,\n        incrementToMax: incrementToMax,\n        decrement: decrement,\n        decrementToMin: decrementToMin,\n        canIncrement: canIncrement,\n        canDecrement: canDecrement,\n        minValue: minValue,\n        maxValue: maxValue,\n        numberValue: parsedValue,\n        setNumberValue: setNumberValue,\n        setInputValue: setInputValue,\n        inputValue: inputValue,\n        commit: commit\n    };\n}\nfunction $de67e98908f0c6ee$var$handleDecimalOperation(operator, value1, value2) {\n    let result = operator === '+' ? value1 + value2 : value1 - value2;\n    // Check if we have decimals\n    if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n        const value1Decimal = value1.toString().split('.');\n        const value2Decimal = value2.toString().split('.');\n        const value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;\n        const value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;\n        const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n        // Transform the decimals to integers based on the precision\n        value1 = Math.round(value1 * multiplier);\n        value2 = Math.round(value2 * multiplier);\n        // Perform the operation on integers values to make sure we don't get a fancy decimal value\n        result = operator === '+' ? value1 + value2 : value1 - value2;\n        // Transform the integer result back to decimal\n        result /= multiplier;\n    }\n    return result;\n}\n\n\n\n//# sourceMappingURL=useNumberFieldState.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrbnVtYmVyZmllbGRAMy45LjhfcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9udW1iZXJmaWVsZC9kaXN0L3VzZU51bWJlckZpZWxkU3RhdGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBdUo7QUFDM0Q7QUFDNkI7QUFDVDs7QUFFaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0EsVUFBVSx1TkFBdU47QUFDak87QUFDQTtBQUNBLDREQUE0RCxpRUFBc0I7QUFDbEYseUJBQXlCLHVEQUFZO0FBQ3JDO0FBQ0E7QUFDQSxtRUFBbUUsaUVBQXNCO0FBQ3pGLGdDQUFnQyx1REFBWTtBQUM1QztBQUNBLDRDQUE0QyxvRUFBeUI7QUFDckUsMENBQTBDLDJDQUFlLHdDQUF3QyxzRUFBc0I7QUFDdkgsMkJBQTJCLDBDQUFjLGNBQWMsbUVBQW1CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQWMsY0FBYyxzRUFBc0I7QUFDMUU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBYztBQUN4QztBQUNBO0FBQ0EscUJBQXFCLDhDQUFrQjtBQUN2QztBQUNBO0FBQ0EseUJBQXlCLHVFQUE2QjtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkNBQWU7QUFDdkQsMENBQTBDLDJDQUFlO0FBQ3pELHdEQUF3RCwyQ0FBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSx1REFBWTtBQUM5RSxnQ0FBZ0MsaUVBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQXNCO0FBQzdDLFVBQVU7QUFDVjtBQUNBO0FBQ0EsK0JBQStCLGlFQUFzQjtBQUNyRDtBQUNBLHVCQUF1QixpRUFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpRUFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBDQUFjLDRHQUE0RyxpRUFBc0I7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMENBQWMsNEdBQTRHLGlFQUFzQjtBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUcwRTtBQUMxRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxQQ1xcU2FuZGJveFxccHJpY2UtdGFnLXByaW50ZXJcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEByZWFjdC1zdGF0ZWx5K251bWJlcmZpZWxkQDMuOS44X3JlYWN0QDE5LjAuMFxcbm9kZV9tb2R1bGVzXFxAcmVhY3Qtc3RhdGVseVxcbnVtYmVyZmllbGRcXGRpc3RcXHVzZU51bWJlckZpZWxkU3RhdGUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7c25hcFZhbHVlVG9TdGVwIGFzICRrTkNQTyRzbmFwVmFsdWVUb1N0ZXAsIGNsYW1wIGFzICRrTkNQTyRjbGFtcCwgdXNlQ29udHJvbGxlZFN0YXRlIGFzICRrTkNQTyR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuaW1wb3J0IHt1c2VGb3JtVmFsaWRhdGlvblN0YXRlIGFzICRrTkNQTyR1c2VGb3JtVmFsaWRhdGlvblN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZm9ybVwiO1xuaW1wb3J0IHtOdW1iZXJGb3JtYXR0ZXIgYXMgJGtOQ1BPJE51bWJlckZvcm1hdHRlciwgTnVtYmVyUGFyc2VyIGFzICRrTkNQTyROdW1iZXJQYXJzZXJ9IGZyb20gXCJAaW50ZXJuYXRpb25hbGl6ZWQvbnVtYmVyXCI7XG5pbXBvcnQge3VzZVN0YXRlIGFzICRrTkNQTyR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAka05DUE8kdXNlTWVtbywgdXNlQ2FsbGJhY2sgYXMgJGtOQ1BPJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cblxuZnVuY3Rpb24gJGRlNjdlOTg5MDhmMGM2ZWUkZXhwb3J0JDdmNjI5ZTlkYzFlY2YzN2MocHJvcHMpIHtcbiAgICBsZXQgeyBtaW5WYWx1ZTogbWluVmFsdWUsIG1heFZhbHVlOiBtYXhWYWx1ZSwgc3RlcDogc3RlcCwgZm9ybWF0T3B0aW9uczogZm9ybWF0T3B0aW9ucywgdmFsdWU6IHZhbHVlLCBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSA9IE5hTiwgb25DaGFuZ2U6IG9uQ2hhbmdlLCBsb2NhbGU6IGxvY2FsZSwgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCwgaXNSZWFkT25seTogaXNSZWFkT25seSB9ID0gcHJvcHM7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB2YWx1ZSA9IE5hTjtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIGlmIChzdGVwICE9PSB1bmRlZmluZWQgJiYgIWlzTmFOKHN0ZXApKSB2YWx1ZSA9ICgwLCAka05DUE8kc25hcFZhbHVlVG9TdGVwKSh2YWx1ZSwgbWluVmFsdWUsIG1heFZhbHVlLCBzdGVwKTtcbiAgICAgICAgZWxzZSB2YWx1ZSA9ICgwLCAka05DUE8kY2xhbXApKHZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgaWYgKHN0ZXAgIT09IHVuZGVmaW5lZCAmJiAhaXNOYU4oc3RlcCkpIGRlZmF1bHRWYWx1ZSA9ICgwLCAka05DUE8kc25hcFZhbHVlVG9TdGVwKShkZWZhdWx0VmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSwgc3RlcCk7XG4gICAgICAgIGVsc2UgZGVmYXVsdFZhbHVlID0gKDAsICRrTkNQTyRjbGFtcCkoZGVmYXVsdFZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUpO1xuICAgIH1cbiAgICBsZXQgW251bWJlclZhbHVlLCBzZXROdW1iZXJWYWx1ZV0gPSAoMCwgJGtOQ1BPJHVzZUNvbnRyb2xsZWRTdGF0ZSkodmFsdWUsIGlzTmFOKGRlZmF1bHRWYWx1ZSkgPyBOYU4gOiBkZWZhdWx0VmFsdWUsIG9uQ2hhbmdlKTtcbiAgICBsZXQgW2lucHV0VmFsdWUsIHNldElucHV0VmFsdWVdID0gKDAsICRrTkNQTyR1c2VTdGF0ZSkoKCk9PmlzTmFOKG51bWJlclZhbHVlKSA/ICcnIDogbmV3ICgwLCAka05DUE8kTnVtYmVyRm9ybWF0dGVyKShsb2NhbGUsIGZvcm1hdE9wdGlvbnMpLmZvcm1hdChudW1iZXJWYWx1ZSkpO1xuICAgIGxldCBudW1iZXJQYXJzZXIgPSAoMCwgJGtOQ1BPJHVzZU1lbW8pKCgpPT5uZXcgKDAsICRrTkNQTyROdW1iZXJQYXJzZXIpKGxvY2FsZSwgZm9ybWF0T3B0aW9ucyksIFtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBmb3JtYXRPcHRpb25zXG4gICAgXSk7XG4gICAgbGV0IG51bWJlcmluZ1N5c3RlbSA9ICgwLCAka05DUE8kdXNlTWVtbykoKCk9Pm51bWJlclBhcnNlci5nZXROdW1iZXJpbmdTeXN0ZW0oaW5wdXRWYWx1ZSksIFtcbiAgICAgICAgbnVtYmVyUGFyc2VyLFxuICAgICAgICBpbnB1dFZhbHVlXG4gICAgXSk7XG4gICAgbGV0IGZvcm1hdHRlciA9ICgwLCAka05DUE8kdXNlTWVtbykoKCk9Pm5ldyAoMCwgJGtOQ1BPJE51bWJlckZvcm1hdHRlcikobG9jYWxlLCB7XG4gICAgICAgICAgICAuLi5mb3JtYXRPcHRpb25zLFxuICAgICAgICAgICAgbnVtYmVyaW5nU3lzdGVtOiBudW1iZXJpbmdTeXN0ZW1cbiAgICAgICAgfSksIFtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBmb3JtYXRPcHRpb25zLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW1cbiAgICBdKTtcbiAgICBsZXQgaW50bE9wdGlvbnMgPSAoMCwgJGtOQ1BPJHVzZU1lbW8pKCgpPT5mb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCksIFtcbiAgICAgICAgZm9ybWF0dGVyXG4gICAgXSk7XG4gICAgbGV0IGZvcm1hdCA9ICgwLCAka05DUE8kdXNlQ2FsbGJhY2spKCh2YWx1ZSk9PmlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCA/ICcnIDogZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSksIFtcbiAgICAgICAgZm9ybWF0dGVyXG4gICAgXSk7XG4gICAgbGV0IHZhbGlkYXRpb24gPSAoMCwgJGtOQ1BPJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHZhbHVlOiBudW1iZXJWYWx1ZVxuICAgIH0pO1xuICAgIGxldCBjbGFtcFN0ZXAgPSBzdGVwICE9PSB1bmRlZmluZWQgJiYgIWlzTmFOKHN0ZXApID8gc3RlcCA6IDE7XG4gICAgaWYgKGludGxPcHRpb25zLnN0eWxlID09PSAncGVyY2VudCcgJiYgKHN0ZXAgPT09IHVuZGVmaW5lZCB8fCBpc05hTihzdGVwKSkpIGNsYW1wU3RlcCA9IDAuMDE7XG4gICAgLy8gVXBkYXRlIHRoZSBpbnB1dCB2YWx1ZSB3aGVuIHRoZSBudW1iZXIgdmFsdWUgb3IgZm9ybWF0IG9wdGlvbnMgY2hhbmdlLiBUaGlzIGlzIGRvbmVcbiAgICAvLyBpbiBhIHVzZUVmZmVjdCBzbyB0aGF0IHRoZSBjb250cm9sbGVkIGJlaGF2aW9yIGlzIGNvcnJlY3QgYW5kIHdlIG9ubHkgdXBkYXRlIHRoZVxuICAgIC8vIHRleHRmaWVsZCBhZnRlciBwcm9wIGNoYW5nZXMuXG4gICAgbGV0IFtwcmV2VmFsdWUsIHNldFByZXZWYWx1ZV0gPSAoMCwgJGtOQ1BPJHVzZVN0YXRlKShudW1iZXJWYWx1ZSk7XG4gICAgbGV0IFtwcmV2TG9jYWxlLCBzZXRQcmV2TG9jYWxlXSA9ICgwLCAka05DUE8kdXNlU3RhdGUpKGxvY2FsZSk7XG4gICAgbGV0IFtwcmV2Rm9ybWF0T3B0aW9ucywgc2V0UHJldkZvcm1hdE9wdGlvbnNdID0gKDAsICRrTkNQTyR1c2VTdGF0ZSkoZm9ybWF0T3B0aW9ucyk7XG4gICAgaWYgKCFPYmplY3QuaXMobnVtYmVyVmFsdWUsIHByZXZWYWx1ZSkgfHwgbG9jYWxlICE9PSBwcmV2TG9jYWxlIHx8IGZvcm1hdE9wdGlvbnMgIT09IHByZXZGb3JtYXRPcHRpb25zKSB7XG4gICAgICAgIHNldElucHV0VmFsdWUoZm9ybWF0KG51bWJlclZhbHVlKSk7XG4gICAgICAgIHNldFByZXZWYWx1ZShudW1iZXJWYWx1ZSk7XG4gICAgICAgIHNldFByZXZMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgc2V0UHJldkZvcm1hdE9wdGlvbnMoZm9ybWF0T3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCBwYXJzZWRWYWx1ZSA9ICgwLCAka05DUE8kdXNlTWVtbykoKCk9Pm51bWJlclBhcnNlci5wYXJzZShpbnB1dFZhbHVlKSwgW1xuICAgICAgICBudW1iZXJQYXJzZXIsXG4gICAgICAgIGlucHV0VmFsdWVcbiAgICBdKTtcbiAgICBsZXQgY29tbWl0ID0gKCk9PntcbiAgICAgICAgLy8gU2V0IHRvIGVtcHR5IHN0YXRlIGlmIGlucHV0IHZhbHVlIGlzIGVtcHR5XG4gICAgICAgIGlmICghaW5wdXRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNldE51bWJlclZhbHVlKE5hTik7XG4gICAgICAgICAgICBzZXRJbnB1dFZhbHVlKHZhbHVlID09PSB1bmRlZmluZWQgPyAnJyA6IGZvcm1hdChudW1iZXJWYWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGl0IGZhaWxlZCB0byBwYXJzZSwgdGhlbiByZXNldCBpbnB1dCB0byBmb3JtYXR0ZWQgdmVyc2lvbiBvZiBjdXJyZW50IG51bWJlclxuICAgICAgICBpZiAoaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICBzZXRJbnB1dFZhbHVlKGZvcm1hdChudW1iZXJWYWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsYW1wIHRvIG1pbiBhbmQgbWF4LCByb3VuZCB0byB0aGUgbmVhcmVzdCBzdGVwLCBhbmQgcm91bmQgdG8gc3BlY2lmaWVkIG51bWJlciBvZiBkaWdpdHNcbiAgICAgICAgbGV0IGNsYW1wZWRWYWx1ZTtcbiAgICAgICAgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCB8fCBpc05hTihzdGVwKSkgY2xhbXBlZFZhbHVlID0gKDAsICRrTkNQTyRjbGFtcCkocGFyc2VkVmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSk7XG4gICAgICAgIGVsc2UgY2xhbXBlZFZhbHVlID0gKDAsICRrTkNQTyRzbmFwVmFsdWVUb1N0ZXApKHBhcnNlZFZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUsIHN0ZXApO1xuICAgICAgICBjbGFtcGVkVmFsdWUgPSBudW1iZXJQYXJzZXIucGFyc2UoZm9ybWF0KGNsYW1wZWRWYWx1ZSkpO1xuICAgICAgICBzZXROdW1iZXJWYWx1ZShjbGFtcGVkVmFsdWUpO1xuICAgICAgICAvLyBpbiBhIGNvbnRyb2xsZWQgc3RhdGUsIHRoZSBudW1iZXJWYWx1ZSB3b24ndCBjaGFuZ2UsIHNvIHdlIHdvbid0IGdvIGJhY2sgdG8gb3VyIG9sZCBpbnB1dCB3aXRob3V0IGhlbHBcbiAgICAgICAgc2V0SW5wdXRWYWx1ZShmb3JtYXQodmFsdWUgPT09IHVuZGVmaW5lZCA/IGNsYW1wZWRWYWx1ZSA6IG51bWJlclZhbHVlKSk7XG4gICAgfTtcbiAgICBsZXQgc2FmZU5leHRTdGVwID0gKG9wZXJhdGlvbiwgbWluTWF4ID0gMCk9PntcbiAgICAgICAgbGV0IHByZXYgPSBwYXJzZWRWYWx1ZTtcbiAgICAgICAgaWYgKGlzTmFOKHByZXYpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgaW5wdXQgaXMgZW1wdHksIHN0YXJ0IGZyb20gdGhlIG1pbi9tYXggdmFsdWUgd2hlbiBpbmNyZW1lbnRpbmcvZGVjcmVtZW50aW5nLFxuICAgICAgICAgICAgLy8gb3IgemVybyBpZiB0aGVyZSBpcyBubyBtaW4vbWF4IHZhbHVlIGRlZmluZWQuXG4gICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBpc05hTihtaW5NYXgpID8gMCA6IG1pbk1heDtcbiAgICAgICAgICAgIHJldHVybiAoMCwgJGtOQ1BPJHNuYXBWYWx1ZVRvU3RlcCkobmV3VmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSwgY2xhbXBTdGVwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgZmlyc3Qgc25hcCB0aGUgY3VycmVudCB2YWx1ZSB0byB0aGUgbmVhcmVzdCBzdGVwLiBpZiBpdCBtb3ZlcyBpbiB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAgICAvLyB3ZSdyZSBnb2luZywgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBhZGQgdGhlIHN0ZXAgYW5kIHNuYXAgdGhhdCB2YWx1ZS5cbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9ICgwLCAka05DUE8kc25hcFZhbHVlVG9TdGVwKShwcmV2LCBtaW5WYWx1ZSwgbWF4VmFsdWUsIGNsYW1wU3RlcCk7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnKycgJiYgbmV3VmFsdWUgPiBwcmV2IHx8IG9wZXJhdGlvbiA9PT0gJy0nICYmIG5ld1ZhbHVlIDwgcHJldikgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuICgwLCAka05DUE8kc25hcFZhbHVlVG9TdGVwKSgkZGU2N2U5ODkwOGYwYzZlZSR2YXIkaGFuZGxlRGVjaW1hbE9wZXJhdGlvbihvcGVyYXRpb24sIHByZXYsIGNsYW1wU3RlcCksIG1pblZhbHVlLCBtYXhWYWx1ZSwgY2xhbXBTdGVwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IGluY3JlbWVudCA9ICgpPT57XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IHNhZmVOZXh0U3RlcCgnKycsIG1pblZhbHVlKTtcbiAgICAgICAgLy8gaWYgd2UndmUgYXJyaXZlZCBhdCB0aGUgc2FtZSB2YWx1ZSB0aGF0IHdhcyBwcmV2aW91c2x5IGluIHRoZSBzdGF0ZSwgdGhlXG4gICAgICAgIC8vIGlucHV0IHZhbHVlIHNob3VsZCBiZSB1cGRhdGVkIHRvIG1hdGNoXG4gICAgICAgIC8vIGV4IHR5cGUgNCwgcHJlc3MgaW5jcmVtZW50LCBoaWdobGlnaHQgdGhlIG51bWJlciBpbiB0aGUgaW5wdXQsIHR5cGUgNCBhZ2FpbiwgcHJlc3MgaW5jcmVtZW50XG4gICAgICAgIC8vIHlvdSdkIGJlIGF0IDUsIHRoZW4gaW5jcmVtZW50aW5nIHRvIDUgYWdhaW4sIHNvIG5vIHJlLXJlbmRlciB3b3VsZCBoYXBwZW4gYW5kIDQgd291bGQgYmUgbGVmdCBpbiB0aGUgaW5wdXRcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudW1iZXJWYWx1ZSkgc2V0SW5wdXRWYWx1ZShmb3JtYXQobmV3VmFsdWUpKTtcbiAgICAgICAgc2V0TnVtYmVyVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICB2YWxpZGF0aW9uLmNvbW1pdFZhbGlkYXRpb24oKTtcbiAgICB9O1xuICAgIGxldCBkZWNyZW1lbnQgPSAoKT0+e1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSBzYWZlTmV4dFN0ZXAoJy0nLCBtYXhWYWx1ZSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gbnVtYmVyVmFsdWUpIHNldElucHV0VmFsdWUoZm9ybWF0KG5ld1ZhbHVlKSk7XG4gICAgICAgIHNldE51bWJlclZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgdmFsaWRhdGlvbi5jb21taXRWYWxpZGF0aW9uKCk7XG4gICAgfTtcbiAgICBsZXQgaW5jcmVtZW50VG9NYXggPSAoKT0+e1xuICAgICAgICBpZiAobWF4VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TnVtYmVyVmFsdWUoKDAsICRrTkNQTyRzbmFwVmFsdWVUb1N0ZXApKG1heFZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUsIGNsYW1wU3RlcCkpO1xuICAgICAgICAgICAgdmFsaWRhdGlvbi5jb21taXRWYWxpZGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBkZWNyZW1lbnRUb01pbiA9ICgpPT57XG4gICAgICAgIGlmIChtaW5WYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXROdW1iZXJWYWx1ZShtaW5WYWx1ZSk7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLmNvbW1pdFZhbGlkYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IGNhbkluY3JlbWVudCA9ICgwLCAka05DUE8kdXNlTWVtbykoKCk9PiFpc0Rpc2FibGVkICYmICFpc1JlYWRPbmx5ICYmIChpc05hTihwYXJzZWRWYWx1ZSkgfHwgbWF4VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpc05hTihtYXhWYWx1ZSkgfHwgKDAsICRrTkNQTyRzbmFwVmFsdWVUb1N0ZXApKHBhcnNlZFZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUsIGNsYW1wU3RlcCkgPiBwYXJzZWRWYWx1ZSB8fCAkZGU2N2U5ODkwOGYwYzZlZSR2YXIkaGFuZGxlRGVjaW1hbE9wZXJhdGlvbignKycsIHBhcnNlZFZhbHVlLCBjbGFtcFN0ZXApIDw9IG1heFZhbHVlKSwgW1xuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICBpc1JlYWRPbmx5LFxuICAgICAgICBtaW5WYWx1ZSxcbiAgICAgICAgbWF4VmFsdWUsXG4gICAgICAgIGNsYW1wU3RlcCxcbiAgICAgICAgcGFyc2VkVmFsdWVcbiAgICBdKTtcbiAgICBsZXQgY2FuRGVjcmVtZW50ID0gKDAsICRrTkNQTyR1c2VNZW1vKSgoKT0+IWlzRGlzYWJsZWQgJiYgIWlzUmVhZE9ubHkgJiYgKGlzTmFOKHBhcnNlZFZhbHVlKSB8fCBtaW5WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKG1pblZhbHVlKSB8fCAoMCwgJGtOQ1BPJHNuYXBWYWx1ZVRvU3RlcCkocGFyc2VkVmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSwgY2xhbXBTdGVwKSA8IHBhcnNlZFZhbHVlIHx8ICRkZTY3ZTk4OTA4ZjBjNmVlJHZhciRoYW5kbGVEZWNpbWFsT3BlcmF0aW9uKCctJywgcGFyc2VkVmFsdWUsIGNsYW1wU3RlcCkgPj0gbWluVmFsdWUpLCBbXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIGlzUmVhZE9ubHksXG4gICAgICAgIG1pblZhbHVlLFxuICAgICAgICBtYXhWYWx1ZSxcbiAgICAgICAgY2xhbXBTdGVwLFxuICAgICAgICBwYXJzZWRWYWx1ZVxuICAgIF0pO1xuICAgIGxldCB2YWxpZGF0ZSA9ICh2YWx1ZSk9Pm51bWJlclBhcnNlci5pc1ZhbGlkUGFydGlhbE51bWJlcih2YWx1ZSwgbWluVmFsdWUsIG1heFZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi52YWxpZGF0aW9uLFxuICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGUsXG4gICAgICAgIGluY3JlbWVudDogaW5jcmVtZW50LFxuICAgICAgICBpbmNyZW1lbnRUb01heDogaW5jcmVtZW50VG9NYXgsXG4gICAgICAgIGRlY3JlbWVudDogZGVjcmVtZW50LFxuICAgICAgICBkZWNyZW1lbnRUb01pbjogZGVjcmVtZW50VG9NaW4sXG4gICAgICAgIGNhbkluY3JlbWVudDogY2FuSW5jcmVtZW50LFxuICAgICAgICBjYW5EZWNyZW1lbnQ6IGNhbkRlY3JlbWVudCxcbiAgICAgICAgbWluVmFsdWU6IG1pblZhbHVlLFxuICAgICAgICBtYXhWYWx1ZTogbWF4VmFsdWUsXG4gICAgICAgIG51bWJlclZhbHVlOiBwYXJzZWRWYWx1ZSxcbiAgICAgICAgc2V0TnVtYmVyVmFsdWU6IHNldE51bWJlclZhbHVlLFxuICAgICAgICBzZXRJbnB1dFZhbHVlOiBzZXRJbnB1dFZhbHVlLFxuICAgICAgICBpbnB1dFZhbHVlOiBpbnB1dFZhbHVlLFxuICAgICAgICBjb21taXQ6IGNvbW1pdFxuICAgIH07XG59XG5mdW5jdGlvbiAkZGU2N2U5ODkwOGYwYzZlZSR2YXIkaGFuZGxlRGVjaW1hbE9wZXJhdGlvbihvcGVyYXRvciwgdmFsdWUxLCB2YWx1ZTIpIHtcbiAgICBsZXQgcmVzdWx0ID0gb3BlcmF0b3IgPT09ICcrJyA/IHZhbHVlMSArIHZhbHVlMiA6IHZhbHVlMSAtIHZhbHVlMjtcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGRlY2ltYWxzXG4gICAgaWYgKHZhbHVlMSAlIDEgIT09IDAgfHwgdmFsdWUyICUgMSAhPT0gMCkge1xuICAgICAgICBjb25zdCB2YWx1ZTFEZWNpbWFsID0gdmFsdWUxLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3QgdmFsdWUyRGVjaW1hbCA9IHZhbHVlMi50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIGNvbnN0IHZhbHVlMURlY2ltYWxMZW5ndGggPSB2YWx1ZTFEZWNpbWFsWzFdICYmIHZhbHVlMURlY2ltYWxbMV0ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGNvbnN0IHZhbHVlMkRlY2ltYWxMZW5ndGggPSB2YWx1ZTJEZWNpbWFsWzFdICYmIHZhbHVlMkRlY2ltYWxbMV0ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgTWF0aC5tYXgodmFsdWUxRGVjaW1hbExlbmd0aCwgdmFsdWUyRGVjaW1hbExlbmd0aCkpO1xuICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIGRlY2ltYWxzIHRvIGludGVnZXJzIGJhc2VkIG9uIHRoZSBwcmVjaXNpb25cbiAgICAgICAgdmFsdWUxID0gTWF0aC5yb3VuZCh2YWx1ZTEgKiBtdWx0aXBsaWVyKTtcbiAgICAgICAgdmFsdWUyID0gTWF0aC5yb3VuZCh2YWx1ZTIgKiBtdWx0aXBsaWVyKTtcbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgb3BlcmF0aW9uIG9uIGludGVnZXJzIHZhbHVlcyB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgZ2V0IGEgZmFuY3kgZGVjaW1hbCB2YWx1ZVxuICAgICAgICByZXN1bHQgPSBvcGVyYXRvciA9PT0gJysnID8gdmFsdWUxICsgdmFsdWUyIDogdmFsdWUxIC0gdmFsdWUyO1xuICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIGludGVnZXIgcmVzdWx0IGJhY2sgdG8gZGVjaW1hbFxuICAgICAgICByZXN1bHQgLz0gbXVsdGlwbGllcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5leHBvcnQgeyRkZTY3ZTk4OTA4ZjBjNmVlJGV4cG9ydCQ3ZjYyOWU5ZGMxZWNmMzdjIGFzIHVzZU51bWJlckZpZWxkU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlTnVtYmVyRmllbGRTdGF0ZS5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-stately+numberfield@3.9.8_react@19.0.0/node_modules/@react-stately/numberfield/dist/useNumberFieldState.mjs\n");

/***/ })

};
;